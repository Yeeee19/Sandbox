<h3> Should we use a reactive-stack web framework like spring webflux when we have blocking calls? </h3>

https://stackoverflow.com/questions/70937652/should-we-use-a-reactive-stack-web-framework-like-spring-webflux-when-we-have-bl

-------

在這裡很難給你一個具體的答案，因為我們不了解你實際的系統架構。

但如果你了解 Reactive 要解決的問題，以及它的運作方式，或許可以幫助你做出更好的判斷。

傳統的 Servlet 模式（大多數 Java Web 伺服器使用）是每個請求分配一個執行緒。

所以當有一個請求進來時，系統會分配一個執行緒來處理這個請求。

如果伺服器在處理過程中呼叫其他服務，而這些呼叫是「阻塞式（blocking）」的，那麼這個執行緒就需要等待回應。

這樣會導致伺服器上有幾百個執行緒大部分時間都在「等」。

這裡的「等」是指真正在空等，一個執行緒可能有 90% 的時間都在等某個阻塞操作的回應。

舉例來說，一個 Web 請求可能本身只需要 3 毫秒處理，但資料庫呼叫阻塞了 200 毫秒（這些數字只是舉例）。

這就表示你花了大量的資源在「等待」。

-------

傳統方式：

每個請求一個執行緒

300 個請求就需要 300 個執行緒

高記憶體使用（每個執行緒都佔用一定記憶體）

CPU 大部分時間都在空等

-------

而 Reactive 的解法是使用所謂的 事件迴圈（event loop） 和一個小型的執行緒池來排程工作。

實務上你可以想像成這樣：一個事件迴圈，可能再加上 10 個執行緒，這些執行緒負責把工作排進事件迴圈。

事件迴圈不停地處理排好的任務，而那些排程執行緒也持續地工作。所以這些執行緒的使用率幾乎是 100%。

在 WebFlux 應用中，事件迴圈的數量通常取決於硬體核心數。 但這也代表應用程式必須是 100% 非阻塞的（non-blocking）。

如果這個架構中出現了一個阻塞操作，那麼整個事件迴圈會被卡住，所有排好的任務都停下來，整個應用可能會凍結，直到這個阻塞解除。

-------

Reactive 模型：

事件迴圈處理所有工作

小型執行緒池排程工作

阻塞操作非常糟糕，可能讓整個應用卡死 。由於執行緒少，記憶體使用量較低

CPU 使用率更高 。可能擁有更高的吞吐量

所以我們本質上是在用記憶體換取 CPU 效能。

-------

那什麼是阻塞呼叫？

大多數的遠端呼叫（像呼叫其他服務）都是阻塞的：你呼叫後要等待回應。

但這正是 Reactive 的優勢之一，因為它還有一個特點：

Reactive 是 執行緒無關（thread-agnostic） 的。

意思是：Reactive 不會綁定某個請求只能用某個特定的執行緒來處理。請求可以由一個執行緒發起，但回應可以由另一個執行緒來處理。

這表示：我們的非阻塞服務即使去呼叫很多阻塞服務，本身仍然可以維持「非阻塞」，因為它在內部的操作流程是非阻塞的。

-------

什麼才是糟糕的阻塞呼叫？

那就是 需要同一條執行緒來處理回應的呼叫。例如你呼叫一個服務，但該服務要求必須是原始的執行緒來處理回應，那麼這就會造成阻塞，因為我們需要讓那條執行緒等待回應。

如果我們必須這樣設計（發起呼叫 → 阻塞等待 → 用同一條執行緒處理回應），那麼我們就 不能用 Reactive，因為你會阻塞事件迴圈，讓整個應用凍結。

例如，所有使用 ThreadLocal 的操作在 Reactive 環境中都是糟糕的。

這就引出了另一個大問題：JDBC（傳統資料庫驅動） 是「天生阻塞」的，因為它靠 ThreadLocal 來追蹤交易狀態以支援 rollback。

所以，使用 JDBC 的資料庫呼叫無法在非阻塞的 Reactive 應用中使用，你必須改用符合 R2DBC 規範的資料庫驅動。

但 REST 呼叫本身不是阻塞的，因為它不依賴特定執行緒（除非你用 ThreadLocal 等功能），而 Spring WebClient 並不使用 ThreadLocal，所以沒問題。

-------

Spring Reactor 提供一個機制，允許你把「舊的方式」（一請求一執行緒）和「新的方式」（執行緒無關）混用。

這表示：如果你確實需要做一個阻塞的操作（例如連接一個舊的資料庫，使用 JDBC 驅動），

你可以明確地告訴框架：「這個操作請用自己的執行緒池處理」，這樣你就等於是對某些部分退回到「傳統方式」。

但請記住：這樣做你就失去了 Reactive 的好處。

所以如果你的服務本身大多都是呼叫阻塞式的後端（例如老舊資料庫），

那你就必須不斷地「跳出」Reactive 模式來處理，這樣就等於是用 Reactive 框架來寫傳統程式，這是一種反模式（anti-pattern）。我不建議這樣做。

-------

以上這些都是基本的電腦知識：執行緒怎麼運作、REST 呼叫怎麼處理、資料庫驅動的行為等。

我無法在一篇 Stack Overflow 的回答裡解釋完電腦怎麼運作。

這些內容在 Reactor 的官方參考資料中也有更多說明，建議你深入研究。

最後，用一個比喻來說：

如果你要走的是一條「轉彎很多、幾乎沒有直線」的路，那你買一台 F1 賽車還有意義嗎？因為你必須一直減速、轉彎，根本開不了快。

這個選擇，就交給你了。